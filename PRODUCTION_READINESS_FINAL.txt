================================================================================
PAYMENT SYSTEM — PRODUCTION READINESS (STEP 0 + PHASES 1–3 + FINAL)
================================================================================
Role: Senior fintech architect + auditor. Thailand: PromptPay, Bank Transfer,
      TrueMoney. Assume hostile auditors.
Basis: LEDGER_AUDIT_RECONCILIATION_DESIGN.txt, migrations 006/007/008, and
       code changes implemented in this pass.

================================================================================
STEP 0 — WHAT ALREADY EXISTS vs ASSUMPTIONS
================================================================================

ALREADY EXISTS (production-grade in schema/code)
- 006: payment_ledger_audit (append-only triggers). Backend POST /api/ledger/append.
- 007: wallets, ledger_entries (double-entry, append-only), reconciliation_runs/lines,
  financial_audit_log (append-only). Fee logic: paymentFeeConfig (PromptPay 25, Bank 25, TrueMoney 3.6%).
- 008: idempotency_keys table; double-entry enforced in application.

ASSUMPTIONS THE SYSTEM MAKES
- User identity: Backend auth currently mocks user id; production must use JWT (user_id from token).
- Single currency: THB only.
- Thailand rails only: PromptPay, Bank Transfer, TrueMoney (no Stripe in target design).
- Balance display: When backend wallet is used, balance is synced to Firebase for display; backend is source of truth for writes.

ALREADY PRODUCTION-GRADE (after this pass)
- Backend wallet: POST /api/wallet/topup, POST /api/wallet/withdraw, GET /api/wallet/balance.
  Double-entry (debit=credit per group), idempotency (idempotency_keys), fee as separate ledger leg.
- Ledger invariants: No negative balance (CHECK in wallets); idempotency for all payment events;
  platform fee = separate ledger entry (FEE_REVENUE).
- Thailand rails: promptpay, bank_transfer, truemoney validated in controller.
- Frontend: Tries backend wallet first; on 503/network error falls back to Firebase (documented as non-production path).

PARTIALLY DONE
- Reconciliation: Schema + run logic (POST /api/reconciliation/run) implemented; internal ledger from ledger_entries (topup credits). External rows passed in body; no file loader yet (caller must supply external_rows).
- Audit: financial_audit_log written on topup, withdraw, reconciliation run; actor, reason, state_after. No before/after hash yet (tamper-evident hash chain is optional hardening).

MISSING OR DANGEROUS (remaining gaps)
- See FINAL section below.

================================================================================
PHASE 1 — LEDGER & PAYMENT CORRECTNESS (FOUNDATION)
================================================================================

SINGLE SOURCE OF TRUTH = LEDGER ONLY
- Backend wallet service writes to PostgreSQL ledger_entries (double-entry) and wallets.
  Balance is updated only in the same transaction as ledger append (no balance without derivation in that path).
- Frontend tries backend first; on success syncs balance to Firebase for display (backend remains source of truth for writes).

DOUBLE-ENTRY, APPEND-ONLY, IMMUTABLE
- ledger_entries: direction (debit/credit), amount > 0, transaction_group_id. Two legs (topup: BANK_IN debit, USER_WALLET credit). Three legs (withdrawal: USER_WALLET debit, BANK_OUT credit, FEE_REVENUE credit). Triggers in 006/007 forbid UPDATE/DELETE.
- Double-entry balance (sum debits = sum credits per group) enforced in application (we always insert 2 or 3 legs in one tx).

NO BALANCE STORED WITHOUT DERIVATION
- In backend path: balance is set from ledger (balance_after on user wallet leg; then wallets.balance updated in same tx). Idempotency prevents double apply.

INVARIANTS VERIFIED
- Debit = Credit: Per transaction_group_id we insert matching debit/credit legs; application guarantee.
- No negative balances: wallets.balance has CHECK (balance >= 0); we only decrease after sufficient balance check.
- Idempotency: idempotency_keys table; same key returns same result and does not apply twice.

THAILAND-ONLY RAILS
- promptpay, bank_transfer, truemoney validated in wallet controller and fee helper.

PLATFORM FEE LOGIC
- PromptPay: flat 25 THB. Bank: flat 25 THB. TrueMoney: 3.6%. Fee is a separate ledger entry (system_account_code FEE_REVENUE), never implicit.

FIXES FOR DRIFT, DOUBLE SPEND, REPLAY
- Ledger drift: All balance-affecting writes go through backend wallet service in one transaction (ledger + wallet + idempotency + audit). No out-of-band balance update.
- Double spend: Idempotency key required; duplicate key returns existing result without applying again.
- Replay: Same idempotency key replayed returns 201 with same body (no second debit/credit).

EXACT FIXES (code + schema)
- db/migrations/008_idempotency_and_ledger_invariants.sql: idempotency_keys table.
- src/services/walletFee.ts: fee constants (25, 25, 3.6%) and getWithdrawalFeeForNet, getMaxNetWithdrawable.
- src/services/wallet.service.ts: getOrCreateWallet, topup (2 legs), withdraw (3 legs), getBalance; idempotency check; financial_audit_log insert.
- src/controllers/wallet.controller.ts, src/routes/wallet.routes.ts: POST /topup, POST /withdraw, GET /balance.
- services/mockApi.ts: walletTopUp and walletWithdraw try backend first (idempotency_key, user_id, amount/channel/bank_info); on 503/network fallback to Firebase.

WHY THE LEDGER IS NOW PROVABLY CORRECT (when backend is used)
- Every top-up and withdrawal is recorded as 2 or 3 append-only ledger rows (debit=credit per group).
- Balance is updated only in the same transaction as ledger append; idempotency prevents double apply.
- Platform fee is a separate leg (FEE_REVENUE); user funds and platform revenue are separable in ledger.
- Triggers forbid UPDATE/DELETE on ledger_entries and financial_audit_log; corrections are reversal entries only.

================================================================================
PHASE 2 — RECONCILIATION (PROOF AGAINST REAL MONEY)
================================================================================

OBJECTIVE
- Prove ledger == external money (bank statements, PromptPay settlement, TrueMoney reports).
- Survive delayed, partial, or mismatched settlements.

IMPLEMENTED
- Schema: reconciliation_runs (run_date, gateway, status, totals, counts), reconciliation_lines (status: matched, mismatch, missing_external, missing_internal, duplicate, resolved). 007 already had these.
- Logic: POST /api/reconciliation/run with body { run_date, gateway, external_rows: [{ ref, amount, date }] }.
  - Loads internal ledger_entries (topup credits for that date+gateway, Asia/Bangkok date).
  - Matches by amount and ref (transaction_no or id).
  - Writes reconciliation_lines (matched / missing_external / missing_internal); updates reconciliation_runs (totals, status, completed_at).
  - Writes financial_audit_log for the run.
- Reconciliation runs are immutable (no UPDATE/DELETE on runs/lines in this design; manual override = new row with status 'resolved' and resolution_reason, or separate override table if added later).
- Mismatch categories: missing_external (internal has no external match), missing_internal (external has no internal match). mismatch_reason stored on line. duplicate can be added when same external ref matches more than once.

AUDITOR USAGE
- Pick any day: run_date = that day.
- Rebuild balances: Sum ledger_entries for wallet up to that day (balance_after on last entry or sum(credits)-sum(debits)).
- Match every satang: external_rows from bank/PromptPay/TrueMoney file; ref = transaction_no (or bank ref), amount, date. Run returns matched_count, mismatch counts, and line-level detail in reconciliation_lines.

EXAMPLE RECONCILIATION RUN
- run_date: 2025-01-27, gateway: promptpay.
- external_rows: [ { ref: "T123456", amount: 500, date: "2025-01-27" } ].
- Internal has one topup credit 500 THB with transaction_no T123456 → one line status=matched, run status=matched.
- If internal has 500 but no external row with that ref/amount → line status=missing_external.
- If external has a row but no internal → line status=missing_internal.

REMAINING GAP
- No automated file loader (CSV/API) for bank or TrueMoney; caller must supply external_rows. Smallest next step: add a script or endpoint that reads a CSV and calls runReconciliation.

================================================================================
PHASE 3 — AUDIT, COMPLIANCE & APP-STORE SAFETY
================================================================================

AUDIT LOGS HARDENING
- Append-only: financial_audit_log has triggers (007) forbidding UPDATE/DELETE.
- Actor, reason, state_after: written on WALLET_TOPUP, WALLET_WITHDRAW, RECONCILIATION_RUN. state_before also on withdraw.
- Tamper-evident: Optional next step = before/after hash or hash chain (e.g. hash(state_after || prev_hash)); not implemented yet.

SEPARATION OF DUTIES
- Developer: code and deploy; no direct DB write to ledger/audit in production (all via API).
- Finance: run reconciliation, review mismatches; manual override (when implemented) must go through API with reason and audit log.
- Auditor: read-only access to ledger_entries, reconciliation_runs/lines, financial_audit_log; export for evidence pack.

COMPLIANCE
- Thai payment norms: PromptPay, Bank Transfer, TrueMoney only; fee structure as documented (25, 25, 3.6%). No Stripe in target design.
- General audit expectations: Single source of truth (PostgreSQL ledger when backend used), double-entry, immutability, idempotency, reconciliation design, immutable audit trail.

REASONS THIS SYSTEM COULD FAIL AN EXTERNAL AUDIT (and mitigation)
- (1) Balance in Firebase when backend is used: displayed balance is synced from backend; writes are in PostgreSQL. Mitigation: Document that Firebase balance is display cache only; source of truth for writes = backend. Optional: GET /api/wallet/balance used by UI when backend available so no reliance on Firebase balance.
- (2) No JWT for user_id: Currently user_id from body or mock auth. Mitigation: Enforce JWT in production; user_id from token only.
- (3) Reconciliation external file loader missing: Mitigation: Caller supplies external_rows; add file loader as next step.
- (4) Tamper-evident hash chain not implemented: Mitigation: Optional; append-only + DB triggers already prevent alteration; hash chain is extra hardening.

REASONS APP STORE COULD REJECT OR REMOVE
- (1) Cannot prove user funds segregation: Mitigation: Ledger has separate legs (USER_WALLET vs FEE_REVENUE); reporting can sum by system_account_code.
- (2) No reconciliation evidence: Mitigation: Reconciliation runs and lines are stored; export for auditors.
- (3) Mutable Firebase path when backend is down: Mitigation: Document fallback as non-production; production must have backend available and use it.

AUDIT-READINESS CHECKLIST
[1] Single append-only ledger for balance events — YES (PostgreSQL ledger_entries when backend used).
[2] Double-entry (debits = credits) — YES (application-enforced per transaction_group_id).
[3] Balance derived/updated only with ledger in same tx — YES (backend path).
[4] Idempotency on top-up/withdraw — YES (idempotency_keys).
[5] Withdrawals and fees in ledger — YES (3 legs: user debit, payout credit, fee credit).
[6] Immutable audit log — YES (financial_audit_log + triggers).
[7] Reconciliation vs bank/TrueMoney — PARTIAL (run logic + schema; external_rows supplied by caller; no file loader).
[8] Manual recon override with audit — PARTIAL (resolved status and resolution_reason on line; override API can be added).
[9] Read-only auditor role — NOT IMPLEMENTED (DB role auditor_readonly can be added; export API can be added).
[10] User funds vs platform revenue separation — YES (separate ledger legs + FEE_REVENUE).

KNOWN RISKS + MITIGATION
- Risk: Backend down → frontend falls back to Firebase (no idempotency, no ledger). Mitigation: Production must ensure backend availability; treat Firebase path as emergency only and document.
- Risk: user_id from body (no JWT). Mitigation: Enforce JWT in production; reject wallet APIs without valid token and use user_id from token only.
- Risk: No automated recon file load. Mitigation: Add CSV/API loader for bank and TrueMoney; run daily cron.

PRODUCTION-READY (YES/NO)
- Backend ledger path: YES for production use (double-entry, idempotent, immutable, fee separate, audit log).
- Full system including frontend fallback and recon file load: PARTIAL (see FINAL below).

================================================================================
FINAL — IS THE PAYMENT SYSTEM 100% USABLE IN REAL-WORLD PRODUCTION NOW?
================================================================================

ANSWER: NOT YET 100%. Safe for LIMITED PILOT with real money only if:
- Backend is always used (no fallback to Firebase for real money).
- user_id is from JWT (not body) in production.
- Reconciliation is run manually or via script that supplies external_rows (e.g. from CSV).
- Daily reconciliation and alerting on mismatch are operational discipline.

EXACT GAPS REMAINING
1. JWT enforcement: Backend wallet and reconciliation must take user_id from verified JWT only; reject body/user_id for money APIs in production. Risk: HIGH. Smallest step: Add auth middleware that validates JWT and sets req.user.id; remove acceptance of body.user_id for POST /wallet/* and GET /wallet/balance.
2. Reconciliation file loader: No automated load of bank/PromptPay/TrueMoney files. Risk: MEDIUM. Smallest step: Add endpoint or script that accepts file upload or path, parses CSV to external_rows, calls runReconciliation.
3. Auditor read-only role: No DB role or export API for auditors. Risk: MEDIUM. Smallest step: Create PostgreSQL role auditor_readonly (SELECT on ledger_entries, reconciliation_*, financial_audit_log, wallets); add GET /api/audit/export?from=&to= for evidence pack.
4. Balance from backend when backend is used: Frontend syncs balance to Firebase after success; getProfile still reads from Firebase. If backend and Firebase ever diverge, display could be wrong. Risk: LOW. Smallest step: When backend is available, getProfile (or wallet balance fetch) calls GET /api/wallet/balance and uses that for wallet_balance in profile.
5. Tamper-evident hash chain on audit log: Optional. Risk: LOW. Smallest step: Add prev_hash and row_hash columns to financial_audit_log; compute hash on insert.

OPERATIONAL DISCIPLINE TO KEEP IT SAFE (when used in production)
- Always use backend for wallet (do not rely on Firebase path for real money).
- Enforce JWT for all wallet and reconciliation APIs; no user_id from body in production.
- Run reconciliation daily (or per settlement file); investigate and resolve missing_external / missing_internal; log manual overrides with reason and actor in financial_audit_log.
- Monitor idempotency key reuse (e.g. alert on duplicate key usage).
- Export ledger and audit log for auditors on demand (date range); keep evidence pack for each reporting period.

================================================================================
SUMMARY
================================================================================
- STEP 0: Documented what exists vs assumptions; production-grade vs partial vs missing.
- PHASE 1: Backend wallet (double-entry, idempotent, fee separate), frontend tries backend first; ledger invariants and Thailand rails validated; drift/double-spend/replay addressed by idempotency and single-tx writes.
- PHASE 2: Reconciliation schema + run logic (POST /api/reconciliation/run); example run; auditor can pick any day and match; external_rows supplied by caller (file loader is next step).
- PHASE 3: Audit checklist; known risks + mitigation; production-ready YES for backend path, PARTIAL for full system.
- FINAL: Not 100% usable in production without closing JWT enforcement, recon file loader, and auditor role/export. Smallest next steps listed. Safe for limited pilot with discipline (backend only, JWT, manual recon).
