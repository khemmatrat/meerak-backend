================================================================================
LEDGER, RECONCILIATION & AUDIT — FINTECH-GRADE DESIGN
================================================================================
Context: Thailand payment infrastructure only (PromptPay, Bank Transfer, TrueMoney).
         No Stripe/Western rails.
Principle: "แอปโดนถอดจาก store ส่วนใหญ่ไม่ใช่เพราะโกง แต่เพราะพิสูจน์ไม่ได้ว่าไม่โกง"
           — Design to PROVE integrity.

================================================================================
STEP 1 — LEDGER REVIEW (EXISTING IMPLEMENTATION)
================================================================================

1.1 SOURCES OF TRUTH
--------------------
- User balance:     Single field wallet_balance on user document.
                    Firebase users/{id}; optionally PostgreSQL users.wallet_balance (001).
- Payment event:    Two disjoint stores:
                    (A) Firebase payment_ledger via ledgerService.ts
                    (B) PostgreSQL payment_ledger_audit via POST /api/ledger/append
- User transactions: Firebase transactions collection (deposit, withdrawal, fee, job payments).
- Audit trail:      Firebase audit_logs (utils/auditLog.ts);
                    PostgreSQL audit_logs / financial_audit_logs (schema.sql, schema_financial.sql).

1.2 LEDGER BEHAVIOUR
--------------------
- payment_ledger (Firebase):
  - appendLedgerEntry() uses setDoc(doc(db, COLLECTION, id), data).
  - NOT append-only at DB level: Firestore allows UPDATE/DELETE; immutability by convention only.
  - Used for: payment_created, payment_completed, payment_failed, payment_expired, payment_refunded, escrow.
  - Deposits: recordPaymentCompleted() called from mockApi after top-up (when ledgerContext provided).
  - Withdrawals: NOT written to this ledger; only user balance update + Firebase transactions.

- payment_ledger_audit (PostgreSQL):
  - Append-only: triggers reject_ledger_audit_update_delete() block UPDATE and DELETE.
  - Frontend does NOT call POST /api/ledger/append; only backend could write.
  - So this table is UNDERUSED and not the single source of truth for in-app flows.

1.3 DEBITS / CREDITS / FEES
---------------------------
- Ledger entries are single-legged "events" (e.g. payment_completed, amount, gateway, job_id, bill_no, transaction_no).
  No double-entry: no paired debit/credit rows, no direction or balance_after in Firebase ledger.
- Balance: Updated in place (updateDoc userRef, wallet_balance). Balance is NOT derived from ledger sum;
  denormalised; can diverge if any write fails after a partial step.
- Fees: Withdrawal fee stored as separate document in transactions (type payment, amount = fee).
  Not in payment_ledger / payment_ledger_audit as a distinct leg (e.g. user debit vs fee revenue).

1.4 EXTERNAL REFERENCES
-----------------------
- Stored in ledger: payment_id, gateway, bill_no, transaction_no, payment_no (optional).
- Sufficient for matching to bank/PromptPay/TrueMoney IF all payment events are written to same append-only store.

1.5 WEAKNESSES & MISSING GUARANTEES
-----------------------------------
 1. Dual ledger (Firebase vs PostgreSQL) with frontend only writing to Firebase
    → Recon and audit cannot rely on one source of truth; PG ledger incomplete.
 2. Firebase payment_ledger is mutable (no trigger/rule forbidding update/delete)
    → Admins or bugs could alter/delete history; not provable to auditor.
 3. Balance is not derived from ledger
    → No invariant "balance = sum(ledger)"; recon cannot verify by recomputing.
 4. No double-entry
    → Cannot prove debits = credits; platform vs user funds not clearly separated in ledger.
 5. No idempotency on top-up/withdraw in mockApi
    → Retries or double-submit can double credit or double debit.
 6. Withdrawals not in ledger
    → Only deposits (when ledgerContext passed) in ledger; withdrawals only in Firebase transactions (mutable).
 7. Firebase transactions is mutable
    → fixNegativeIncomes updates docs; emergencyRemoveDuplicateTransactions deletes docs — not acceptable as audit trail.
 8. Audit log (Firebase) is mutable
    → Who/when/why logged but logs can be changed/deleted; not tamper-evident.
 9. No bank/TrueMoney reconciliation
    → No matching internal ledger to bank statements or TrueMoney settlement files.
10. FinancialAuditView uses mock data
    → Admin "reconciliation" is simulated; not tied to real ledger or bank data.

================================================================================
STEP 2 — LEDGER INVARIANTS (MUST HOLD)
================================================================================

I1. Single source of truth for money movement
    - All balance-affecting events in ONE append-only ledger (prefer PostgreSQL).
    - User balance either (a) derived from ledger, or (b) cached and verified daily against ledger.

I2. Double-entry integrity
    - For every business transaction: total debits = total credits (THB).
    - At least two legs (e.g. user wallet debit + system revenue credit).
    - Ledger has direction (debit/credit) and amount > 0; balance = signed sum by direction.

I3. Immutability
    - Ledger: INSERT only. No UPDATE, no DELETE (DB triggers). Corrections = reversal/compensation entries.

I4. Idempotency
    - Every balance-affecting API accepts idempotency key. Same key → same result; no double apply.

I5. Currency and precision
    - All amounts THB; NUMERIC(18,2). Rounding: 2 decimals, rule documented (see PAYMENT_FEE_DESIGN.txt).

I6. Fee separation
    - User funds (wallet) and platform revenue (fees) are separate legs in ledger.
    - Withdrawal: (1) Debit user wallet (net+fee), (2) Credit payout (net), (3) Credit platform fee revenue.

I7. Reversal / compensation (no deletion)
    - Wrong or reversed: NEW ledger entries (reversal/compensation) with reference to original. No row update/delete.

================================================================================
STEP 3 — RECONCILIATION DESIGN
================================================================================

3.1 OBJECTIVES
--------------
- Reconcile internal ledger with:
  - Bank: PromptPay / Bank transfer (inbound and outbound) via statements or API.
  - TrueMoney: Settlement reports (CSV/API).
- Support: daily automated runs, manual override with audit trail, partial and delayed (T+1/T+3) settlements.

3.2 MATCHING KEYS
-----------------
- PromptPay / Bank credit:  transaction_no + date + amount (fallback: bill_no, payment_id).
- TrueMoney settlement:    transaction_no or provider ref + amount + date (fallback: payment_id).
- Bank withdrawal (payout): Internal payout_id + amount + date (fallback: user ref + amount).
- Internal ledger must store: gateway, transaction_no, bill_no, payment_id, amount, currency, created_at;
  for withdrawals: payout_id, channel.

3.3 RECONCILIATION STATES (per run or per line)
----------------------------------------------
  PENDING       → Run started, not yet compared.
  MATCHED       → Internal row matched to one external row, amount/date OK.
  MISMATCH      → Amount or date mismatch (alert).
  MISSING_EXT   → Internal entry has no external counterpart (e.g. not yet settled).
  MISSING_INT   → External row has no internal counterpart (orphan; possible duplicate credit).
  DUPLICATE     → Same external ref matched more than once (duplicate credit risk).
  RESOLVED      → Manual override after investigation; reason + auditor logged.
  FAILED        → Run error; retry or escalate.

3.4 WHAT RECONCILIATION DETECTS
------------------------------
- Missing transactions: Internal has entry but no bank/TrueMoney line.
- Duplicate credits: Same transaction_no or external ref credited more than once.
- Amount mismatches: Internal amount != external amount (critical alert).
- Orphan ledger entries: Internal with no external ref (test/manual) — must be tagged and justified.
- Orphan external lines: Bank/TrueMoney line with no internal match — possible missing credit or duplicate payout.

3.5 FAILURE STATES AND ESCALATION
---------------------------------
- MISMATCH / DUPLICATE: Auto-alert (e.g. Slack/email); lock related payouts until reviewed.
- MISSING_EXT (T+3): Escalate to ops; consider withholding payout until matched.
- RESOLVED: Only with reason, actor, timestamp in reconciliation_overrides (audit-only); no deletion of original.

3.6 HIGH-LEVEL FLOW (pseudocode)
--------------------------------
  RECON_RUN(date, provider):
    internal_rows = SELECT * FROM payment_ledger_audit WHERE date(created_at)=date AND gateway=provider
    external_rows = LOAD_BANK_OR_TRUEMONEY_FILE(date, provider)

    FOR each internal_row:
      match = FIND_EXTERNAL(external_rows, internal_row.transaction_no, amount, date)
      IF match FOUND AND amount OK:  SET status=MATCHED, link match_id
      ELIF match FOUND AND amount<>: SET status=MISMATCH, alert
      ELSE: SET status=MISSING_EXT

    FOR each external_row:
      IF NOT linked to any internal: ADD as MISSING_INT, alert

    CHECK duplicate external refs → mark DUPLICATE, alert
    PERSIST recon_run + line_items with states

================================================================================
STEP 4 — AUDIT LOG SYSTEM (NON-NEGOTIABLE)
================================================================================

4.1 REQUIREMENTS
----------------
- Append-only: INSERT only; no UPDATE/DELETE (DB-enforced).
- Tamper-evident: Hash chain or hashes of critical fields so any change is detectable.
- No admin override: Even super-admins cannot modify or delete audit log rows.

4.2 WHAT EACH RECORD MUST CONTAIN
---------------------------------
  actor_id / actor_type   → Who (user id, system, cron).
  action                  → What (e.g. LEDGER_APPEND, WITHDRAWAL_REQUEST, RECON_MATCH, RECON_OVERRIDE).
  entity_type + entity_id → On what (ledger entry id, wallet id, recon_run id).
  state_before / state_after → What changed (JSON diff or snapshot for critical tables).
  reason / business_reason  → Why.
  correlation_id / request_id → Trace across services.
  external_ref            → e.g. bank ref, TrueMoney transaction id.
  timestamp (server)      → When.
  ip / user_agent (if user-driven) → Where from.

4.3 SCOPE (must be logged)
---------------------------
- Every ledger write (append): at least id, event_type, amount, gateway, reference ids.
- Every balance-affecting action: top-up, withdraw, release, refund, fee booking, adjustment.
- Every withdrawal request: amount, channel, fee, user, idempotency key, result.
- Reconciliation: run start/end, match/mismatch/orphan, and any manual override (who, why, before/after).
- Admin interventions: balance adjustments, manual match, reversal — with mandatory reason.

4.4 IMPLEMENTATION NOTE
-----------------------
- Prefer PostgreSQL table with trigger rejecting UPDATE/DELETE (like payment_ledger_audit).
- Firebase audit_logs acceptable only for non-financial audit; for money and recon, authoritative log must be immutable and in same DB as ledger.

================================================================================
STEP 5 — DATA MODEL & SCHEMA
================================================================================

5.1 LEDGER (append-only, double-entry capable)
----------------------------------------------
  CREATE TABLE ledger_entries (
      id BIGSERIAL PRIMARY KEY,
      idempotency_key VARCHAR(255) UNIQUE NOT NULL,

      transaction_group_id UUID NOT NULL,
      event_type VARCHAR(50) NOT NULL,
      direction VARCHAR(10) NOT NULL CHECK (direction IN ('debit', 'credit')),
      amount NUMERIC(18,2) NOT NULL CHECK (amount > 0),
      currency VARCHAR(3) NOT NULL DEFAULT 'THB',

      wallet_id UUID REFERENCES wallets(id),
      system_account_code VARCHAR(50),

      balance_after NUMERIC(18,2),
      description TEXT NOT NULL,

      gateway VARCHAR(50),
      payment_id TEXT,
      transaction_no TEXT,
      bill_no TEXT,
      reference_ledger_id BIGINT REFERENCES ledger_entries(id),

      created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
      created_by TEXT,
      metadata JSONB DEFAULT '{}'
  );

  -- Enforce append-only (same trigger as payment_ledger_audit).
  CREATE INDEX idx_ledger_wallet_created ON ledger_entries(wallet_id, created_at);
  CREATE INDEX idx_ledger_group ON ledger_entries(transaction_group_id);
  CREATE INDEX idx_ledger_idempotency ON ledger_entries(idempotency_key);
  CREATE INDEX idx_ledger_transaction_no ON ledger_entries(gateway, transaction_no);

  payment_ledger_audit can remain for event log (payment_created, payment_completed) and recon matching;
  ledger_entries is the double-entry source of truth for balance derivation. Alternatively migrate to one table.

5.2 RECONCILIATION
------------------
  reconciliation_runs: id, run_date, gateway, status, total_internal_amount, total_external_amount,
                       mismatch_count, matched_count, missing_internal_count, missing_external_count,
                       report_path, started_at, completed_at, error_message.

  reconciliation_lines: id, run_id, status (matched|mismatch|missing_external|missing_internal|duplicate|resolved),
                        internal_ledger_id, internal_amount, internal_transaction_no,
                        external_ref, external_amount, external_date, mismatch_reason,
                        resolved_at, resolved_by, resolution_reason.

  Indexes: run_date+gateway, run_id.

5.3 AUDIT LOG (immutable)
-------------------------
  financial_audit_log: id, actor_type, actor_id, action, entity_type, entity_id,
                       state_before, state_after, reason, correlation_id, external_ref,
                       created_at, ip_address, user_agent.
  Trigger: reject UPDATE/DELETE (same as payment_ledger_audit).

5.4 WALLETS
-----------
- One wallet per user per currency. Balance updates ONLY via ledger process: append ledger_entries then update wallets.balance and last_ledger_id in same transaction. Trigger can enforce "no direct balance update without ledger".

================================================================================
STEP 6 — OPERATIONAL CONTROLS
================================================================================

6.1 Read-only audit views
-------------------------
- Role auditor_readonly: SELECT on ledger_entries, reconciliation_runs, reconciliation_lines, financial_audit_log, wallets. No INSERT/UPDATE/DELETE.
- Views: v_ledger_with_balance (ledger + running balance by wallet), v_recon_daily_summary (per run_date, gateway, counts and amounts).

6.2 Exportable reports
----------------------
- Reconciliation report (CSV/Excel): run_id, run_date, gateway, status, line-level internal_ref, external_ref, amounts, status, mismatch_reason.
- Ledger roll-forward: For date range, list all ledger entries with balance_after (or computed balance).
- Ledger roll-backward: Same by wallet from current balance backward.
- Evidence pack for auditors: Ledger export + recon runs + audit log excerpt; checksum or signed export.

6.3 Separation of duties
-------------------------
- System: All normal ledger appends and balance updates (backend only; frontend never writes ledger directly).
- Admin: Manual recon override, manual adjustment — only through flows that write to financial_audit_log with reason; no raw UPDATE/DELETE on ledger or audit log.
- Auditor: Read-only; export only.

================================================================================
STEP 7 — COMPLIANCE READINESS
================================================================================

7.1 International audit expectations
-------------------------------------
- Single source of truth for money movement (ledger).
- Immutability and no deletion of financial history.
- Double-entry or equivalent (debits = credits).
- Idempotency so duplicate requests do not duplicate money.
- Reconciliation with external sources (bank, TrueMoney) with clear matching and exception handling.
- Audit trail that cannot be altered by anyone, including admins.

7.2 Fintech / app store risk mitigation
--------------------------------------
- User funds vs platform revenue: Clearly separated in ledger (user wallet vs system fee revenue).
- Proof of "no fraud": Daily recon, immutable audit log, exportable evidence.
- Thailand-only: PromptPay, Bank Transfer, TrueMoney; matching keys and settlement timing align with local bank and TrueMoney reports.

7.3 AUDIT-READINESS CHECKLIST
-----------------------------
  1. Single append-only ledger for all balance events     [ ] Current: dual; Target: one PG ledger.
  2. Double-entry (debits = credits)                       [ ] Current: no; Target: ledger with direction.
  3. Balance derived or verified against ledger            [ ] Current: no; Target: daily check or derivation.
  4. Idempotency on top-up/withdraw                        [ ] Current: no; Target: idempotency key on all money APIs.
  5. Withdrawals recorded in ledger                        [ ] Current: no; Target: withdrawal + fee as ledger legs.
  6. Immutable audit log (no update/delete)                 [ ] Current: Firebase mutable; Target: PG table + trigger.
  7. Reconciliation vs bank/TrueMoney                      [ ] Current: no; Target: daily runs, matching keys, states.
  8. Manual recon override with reason + audit             [ ] Current: mock only; Target: override table + audit log.
  9. Read-only auditor role + export                       [ ] Current: no; Target: role + views + export API.
 10. User funds vs platform revenue separation             [ ] Current: logic only; Target: separate ledger legs + reporting.

================================================================================
ARCHITECTURE DIAGRAM (TEXT)
================================================================================

                    +------------------+
                    |  Bank / TrueMoney |
                    |  (Statements /   |
                    |   Settlement)    |
                    +--------+---------+
                             |
                             v
+-------------+     +----------------+     +--------------------+
|  Client     |     |  Backend       |     |  Reconciliation     |
|  (App)      |---->|  Ledger API    |---->|  Job (daily)        |
|             |     |  (append only) |     |  Match + Alerts     |
+-------------+     +--------+-------+     +----------+---------+
                             |                        |
                             v                        v
                    +----------------+       +------------------+
                    |  ledger_entries|       | reconciliation_  |
                    |  (double-entry)|       | runs + lines     |
                    +--------+-------+       +------------------+
                             |
         +-------------------+-------------------+
         v                   v                   v
   +-----------+     +---------------+     +------------------+
   |  wallets  |     |  payment_     |     | financial_       |
   |  (balance)|     |  ledger_audit |     | audit_log        |
   |           |     |  (events)     |     | (immutable)      |
   +-----------+     +---------------+     +------------------+

================================================================================
SUMMARY
================================================================================
- Step 1: Current setup has two ledgers (Firebase + PostgreSQL), mutable transactions and audit in Firebase, no double-entry, no idempotency, no real reconciliation with bank/TrueMoney.
- Steps 2–7: Invariants (single source, double-entry, immutability, idempotency, fee separation, reversal-only), reconciliation design (matching keys, states, failure handling), immutable audit log, schema proposals for ledger/recon/audit, operational controls (read-only views, exports, separation of duties), and compliance checklist so the platform can PROVE it does not misuse user funds and is ready for external audit and app store financial review.

Implementation order:
1. Make PostgreSQL the single ledger for all balance-affecting events (sync or retire Firebase payment_ledger).
2. Add double-entry legs for deposits, withdrawals, and fees.
3. Enforce idempotency in wallet APIs.
4. Write all withdrawals and fees into the ledger.
5. Build reconciliation pipeline against bank/TrueMoney files.
6. Move financial audit trail to immutable PG table.
7. Introduce auditor role and export capabilities.
