/**
 * Phase 1: Authentication & OTP - Device Binding Service
 * 
 * Manages device registration, trusted devices, and device-based authentication
 */

import { db } from './firebase';
import { doc, setDoc, getDoc, updateDoc, collection, query, where, getDocs, deleteDoc } from 'firebase/firestore';
import { createLogger, RequestContext } from '../utils/tracing';
import { logCreate, logUpdate } from '../utils/auditLog';

/**
 * Device Platform
 */
export type DevicePlatform = 'ios' | 'android' | 'web' | 'desktop';

/**
 * Device Record Interface
 */
export interface DeviceRecord {
  id: string;                      // Device ID (generated by client)
  user_id: string;                 // User who owns this device
  
  // Device Info
  device_name: string;             // e.g., "iPhone 13", "Chrome on MacBook"
  platform: DevicePlatform;
  device_model?: string;
  os_version?: string;
  app_version?: string;
  
  // Network Info
  ip_address?: string;
  user_agent?: string;
  
  // Trust Status
  is_trusted: boolean;             // Trusted device (skip OTP)
  trusted_at?: string;             // When marked as trusted
  trust_expires_at?: string;       // Trust expiry (30 days)
  
  // Login History
  first_login: string;
  last_login: string;
  login_count: number;
  
  // Status
  is_active: boolean;
  blocked: boolean;
  blocked_reason?: string;
  
  // Security
  fingerprint: string;             // Device fingerprint hash
  
  // Tracing
  request_id?: string;
  trace_id?: string;
  
  // Audit
  created_at: string;
  updated_at: string;
}

/**
 * Generate device fingerprint from device info (Browser-compatible)
 */
function generateFingerprint(
  deviceId: string,
  userAgent: string,
  platform: DevicePlatform
): string {
  // Simple hash using btoa (browser-compatible base64)
  const data = `${deviceId}:${userAgent}:${platform}`;
  try {
    return btoa(data).substring(0, 32);
  } catch (e) {
    // Fallback if btoa fails (non-ASCII characters)
    return btoa(encodeURIComponent(data)).substring(0, 32);
  }
}

/**
 * Register new device
 * 
 * @param userId - User ID
 * @param deviceId - Device ID (from client)
 * @param deviceInfo - Device information
 * @param context - Request context
 * @returns Device record or error
 */
export async function registerDevice(
  userId: string,
  deviceId: string,
  deviceInfo: {
    device_name: string;
    platform: DevicePlatform;
    device_model?: string;
    os_version?: string;
    app_version?: string;
    ip_address?: string;
    user_agent?: string;
  },
  context?: RequestContext
): Promise<{ success: boolean; device?: DeviceRecord; error?: string }> {
  const logger = context ? createLogger(context) : null;
  
  try {
    logger?.info('Registering device', { userId, deviceId });
    
    // Check if device already exists
    const deviceRef = doc(db, 'devices', deviceId);
    const deviceSnap = await getDoc(deviceRef);
    
    if (deviceSnap.exists()) {
      const existingDevice = deviceSnap.data() as DeviceRecord;
      
      // Update last login
      await updateDoc(deviceRef, {
        last_login: new Date().toISOString(),
        login_count: existingDevice.login_count + 1,
        ip_address: deviceInfo.ip_address,
        updated_at: new Date().toISOString()
      });
      
      logger?.info('Device already registered, updated last login', { deviceId });
      
      return {
        success: true,
        device: {
          ...existingDevice,
          last_login: new Date().toISOString(),
          login_count: existingDevice.login_count + 1
        }
      };
    }
    
    // Create fingerprint
    const fingerprint = generateFingerprint(
      deviceId,
      deviceInfo.user_agent || '',
      deviceInfo.platform
    );
    
    // Create new device record
    const deviceRecord: DeviceRecord = {
      id: deviceId,
      user_id: userId,
      device_name: deviceInfo.device_name,
      platform: deviceInfo.platform,
      device_model: deviceInfo.device_model,
      os_version: deviceInfo.os_version,
      app_version: deviceInfo.app_version,
      ip_address: deviceInfo.ip_address,
      user_agent: deviceInfo.user_agent,
      is_trusted: false,  // New devices are not trusted by default
      first_login: new Date().toISOString(),
      last_login: new Date().toISOString(),
      login_count: 1,
      is_active: true,
      blocked: false,
      fingerprint,
      request_id: context?.request_id,
      trace_id: context?.trace_id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    // Remove undefined fields (Firestore doesn't allow undefined)
    const cleanedRecord = Object.fromEntries(
      Object.entries(deviceRecord).filter(([_, v]) => v !== undefined)
    );
    
    await setDoc(deviceRef, cleanedRecord);
    
    // Log audit
    if (context) {
      await logCreate('devices', deviceId, deviceRecord, context, {
        user_id: userId,
        action_type: 'register_device'
      });
    }
    
    logger?.info('Device registered successfully', { deviceId });
    
    return {
      success: true,
      device: deviceRecord
    };
    
  } catch (error: any) {
    logger?.error('Error registering device', error);
    return {
      success: false,
      error: error.message || 'Failed to register device'
    };
  }
}

/**
 * Check if device is trusted
 * 
 * @param deviceId - Device ID
 * @param userId - User ID
 * @returns True if device is trusted and trust hasn't expired
 */
export async function isTrustedDevice(
  deviceId: string,
  userId: string
): Promise<boolean> {
  try {
    const deviceRef = doc(db, 'devices', deviceId);
    const deviceSnap = await getDoc(deviceRef);
    
    if (!deviceSnap.exists()) {
      return false;
    }
    
    const device = deviceSnap.data() as DeviceRecord;
    
    // Check if device belongs to user
    if (device.user_id !== userId) {
      return false;
    }
    
    // Check if device is blocked
    if (device.blocked) {
      return false;
    }
    
    // Check if device is trusted
    if (!device.is_trusted) {
      return false;
    }
    
    // Check if trust has expired
    if (device.trust_expires_at) {
      const expiryDate = new Date(device.trust_expires_at);
      if (expiryDate < new Date()) {
        // Trust expired, remove trust
        await updateDoc(deviceRef, {
          is_trusted: false,
          trusted_at: null,
          trust_expires_at: null,
          updated_at: new Date().toISOString()
        });
        return false;
      }
    }
    
    return true;
    
  } catch (error) {
    console.error('Error checking trusted device:', error);
    return false;
  }
}

/**
 * Mark device as trusted
 * 
 * @param deviceId - Device ID
 * @param userId - User ID
 * @param trustDays - Number of days to trust (default: 30)
 * @param context - Request context
 */
export async function trustDevice(
  deviceId: string,
  userId: string,
  trustDays: number = 30,
  context?: RequestContext
): Promise<{ success: boolean; error?: string }> {
  const logger = context ? createLogger(context) : null;
  
  try {
    logger?.info('Trusting device', { deviceId, userId, trustDays });
    
    const deviceRef = doc(db, 'devices', deviceId);
    const deviceSnap = await getDoc(deviceRef);
    
    if (!deviceSnap.exists()) {
      return { success: false, error: 'Device not found' };
    }
    
    const device = deviceSnap.data() as DeviceRecord;
    const oldData = { ...device };
    
    // Verify device belongs to user
    if (device.user_id !== userId) {
      return { success: false, error: 'Device does not belong to user' };
    }
    
    // Calculate trust expiry
    const trustExpiresAt = new Date();
    trustExpiresAt.setDate(trustExpiresAt.getDate() + trustDays);
    
    // Update device
    await updateDoc(deviceRef, {
      is_trusted: true,
      trusted_at: new Date().toISOString(),
      trust_expires_at: trustExpiresAt.toISOString(),
      updated_at: new Date().toISOString()
    });
    
    // Log audit
    if (context) {
      const newData = {
        ...device,
        is_trusted: true,
        trusted_at: new Date().toISOString(),
        trust_expires_at: trustExpiresAt.toISOString()
      };
      
      await logUpdate('devices', deviceId, oldData, newData, context, {
        user_id: userId,
        action_type: 'trust_device',
        reason: `Trust device for ${trustDays} days`
      });
    }
    
    logger?.info('Device trusted successfully', {
      deviceId,
      expiresAt: trustExpiresAt.toISOString()
    });
    
    return { success: true };
    
  } catch (error: any) {
    logger?.error('Error trusting device', error);
    return {
      success: false,
      error: error.message || 'Failed to trust device'
    };
  }
}

/**
 * Revoke trust from device
 */
export async function untrustDevice(
  deviceId: string,
  userId: string,
  context?: RequestContext
): Promise<{ success: boolean; error?: string }> {
  const logger = context ? createLogger(context) : null;
  
  try {
    logger?.info('Untrusting device', { deviceId, userId });
    
    const deviceRef = doc(db, 'devices', deviceId);
    const deviceSnap = await getDoc(deviceRef);
    
    if (!deviceSnap.exists()) {
      return { success: false, error: 'Device not found' };
    }
    
    const device = deviceSnap.data() as DeviceRecord;
    const oldData = { ...device };
    
    if (device.user_id !== userId) {
      return { success: false, error: 'Device does not belong to user' };
    }
    
    await updateDoc(deviceRef, {
      is_trusted: false,
      trusted_at: null,
      trust_expires_at: null,
      updated_at: new Date().toISOString()
    });
    
    if (context) {
      const newData = {
        ...device,
        is_trusted: false,
        trusted_at: null,
        trust_expires_at: null
      };
      
      await logUpdate('devices', deviceId, oldData, newData, context, {
        user_id: userId,
        action_type: 'untrust_device'
      });
    }
    
    logger?.info('Device untrusted successfully', { deviceId });
    
    return { success: true };
    
  } catch (error: any) {
    logger?.error('Error untrusting device', error);
    return {
      success: false,
      error: error.message || 'Failed to untrust device'
    };
  }
}

/**
 * Get all devices for user
 */
export async function getUserDevices(userId: string): Promise<DeviceRecord[]> {
  try {
    const devicesQuery = query(
      collection(db, 'devices'),
      where('user_id', '==', userId),
      where('is_active', '==', true)
    );
    
    const snapshot = await getDocs(devicesQuery);
    const devices: DeviceRecord[] = [];
    
    snapshot.forEach((doc) => {
      devices.push(doc.data() as DeviceRecord);
    });
    
    // Sort by last login (most recent first)
    devices.sort((a, b) => 
      new Date(b.last_login).getTime() - new Date(a.last_login).getTime()
    );
    
    return devices;
    
  } catch (error) {
    console.error('Error getting user devices:', error);
    return [];
  }
}

/**
 * Block device
 */
export async function blockDevice(
  deviceId: string,
  reason: string,
  context?: RequestContext
): Promise<{ success: boolean; error?: string }> {
  try {
    const deviceRef = doc(db, 'devices', deviceId);
    const deviceSnap = await getDoc(deviceRef);
    
    if (!deviceSnap.exists()) {
      return { success: false, error: 'Device not found' };
    }
    
    const device = deviceSnap.data() as DeviceRecord;
    const oldData = { ...device };
    
    await updateDoc(deviceRef, {
      blocked: true,
      blocked_reason: reason,
      is_trusted: false,
      updated_at: new Date().toISOString()
    });
    
    if (context) {
      const newData = { ...device, blocked: true, blocked_reason: reason };
      await logUpdate('devices', deviceId, oldData, newData, context, {
        action_type: 'block_device',
        reason
      });
    }
    
    console.log(`üö´ Device ${deviceId} blocked: ${reason}`);
    
    return { success: true };
    
  } catch (error: any) {
    console.error('Error blocking device:', error);
    return {
      success: false,
      error: error.message || 'Failed to block device'
    };
  }
}

/**
 * Remove device
 */
export async function removeDevice(
  deviceId: string,
  userId: string,
  context?: RequestContext
): Promise<{ success: boolean; error?: string }> {
  try {
    const deviceRef = doc(db, 'devices', deviceId);
    const deviceSnap = await getDoc(deviceRef);
    
    if (!deviceSnap.exists()) {
      return { success: false, error: 'Device not found' };
    }
    
    const device = deviceSnap.data() as DeviceRecord;
    
    if (device.user_id !== userId) {
      return { success: false, error: 'Device does not belong to user' };
    }
    
    // Soft delete (mark as inactive)
    await updateDoc(deviceRef, {
      is_active: false,
      is_trusted: false,
      updated_at: new Date().toISOString()
    });
    
    console.log(`üóëÔ∏è Device ${deviceId} removed for user ${userId}`);
    
    return { success: true };
    
  } catch (error: any) {
    console.error('Error removing device:', error);
    return {
      success: false,
      error: error.message || 'Failed to remove device'
    };
  }
}
